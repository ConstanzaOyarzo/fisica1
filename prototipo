import tkinter as tk
from tkinter import ttk
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from PIL import Image, ImageTk

# Crear la ventana principal
ventana = tk.Tk()

# Obtener el tamaño de la pantalla
anPanta = ventana.winfo_screenwidth()
alPanta = ventana.winfo_screenheight()

#mitad
anCuarto = anPanta // 2
alCuarto = alPanta // 2

# Crear los marcos para cada cuarto de la pantalla
marco_1 = tk.Frame(ventana, width=anCuarto,height=alCuarto, bg='#CC99FF')
marco_2 = tk.Frame(ventana, width=anCuarto, height=alCuarto, bg = 'blue')
marco_3 = tk.Frame(ventana, width=anCuarto, height=alCuarto, bg='#99CCFF')
marco_4 = tk.Frame(ventana, width=anCuarto, height=alCuarto, bg='#FFFF99')

# Colocar los marcos en la ventana
marco_1.grid(row=0, column=0)
marco_2.grid(row=0, column=1)
marco_3.grid(row=1, column=0)
marco_4.grid(row=1, column=1)


########################################################################
#                               Caja
########################################################################

class GFG:
    def __init__(self, marco=None): # self se utiliza para acceder y asignar atributos específicos a dicha instancia.
        self.marco_1 = marco

        # coordenadas iniciales
        self.x = 0
        self.y = 0

        # crear rectangulo en la esquina inferior izquierda
        self.rectangle = tk.Frame(self.marco_1, width=50, height=50, bg='#683343')
        self.rectangle.pack()

        # flag para indicar si se debe mover o no
        self.move_enabled = False

    def movimiento(self):
        if self.move_enabled:
            # Obtener las dimensiones del marco
            ancho_marco = self.marco_1.winfo_width()
            alto_marco = self.marco_1.winfo_height()

            # Calcular las nuevas coordenadas
            nueva_x = self.rectangle.winfo_x() + self.x
            nueva_y = self.rectangle.winfo_y() + self.y

            # Verificar los límites del rectángulo
            if 0 <= nueva_x <= ancho_marco - self.rectangle.winfo_width():
                if 0 <= nueva_y <= alto_marco - self.rectangle.winfo_height():
                    self.rectangle.place(x=nueva_x, y=nueva_y)

            self.move_enabled = False
        self.marco_1.after(1, self.movimiento)

    # movmiento a la izquierda
    def izquierda(self, event):
        self.x = -5
        self.y = 0
        self.move_enabled = True

    # movimiento a la derecha
    def derecha(self, event):
        self.x = 5
        self.y = 0
        self.move_enabled = True

    # movimiento hacia arriba
    def arriba(self, event):
        self.x = 0
        self.y = -5
        self.move_enabled = True

    # movimiento hacia abajo
    def abajo(self, event):
        self.x = 0
        self.y = 5
        self.move_enabled = True

    # movimiento diagonal arriba-derecha
    def diagonal_arriba_derecha(self, event):
        self.x = 5
        self.y = -5
        self.move_enabled = True

    # movimiento diagonal arriba-izquierda
    def diagonal_arriba_izquierda(self, event):
        self.x = -5
        self.y = -5
        self.move_enabled = True


# Crear instancia de GFG dentro del marco 1
gfg = GFG(marco_1)

# Establecer la posición inicial del rectángulo en la esquina inferior izquierda
gfg.rectangle.place(x=anPanta//2//2, y=alPanta//2 - 55)


# Controlar movimiento por teclado
ventana.bind("<KeyPress-a>", lambda e: gfg.izquierda(e))
ventana.bind("<KeyPress-d>", lambda e: gfg.derecha(e))
ventana.bind("<KeyPress-w>", lambda e: gfg.arriba(e))
ventana.bind("<KeyPress-s>", lambda e: gfg.abajo(e))
ventana.bind("<KeyPress-e>", lambda e: gfg.diagonal_arriba_derecha(e))
ventana.bind("<KeyPress-q>", lambda e: gfg.diagonal_arriba_izquierda(e))
ventana.after(0, gfg.movimiento)


############################################################################
#                               Personaje
############################################################################

# Cargar la imagen del personaje
imaP = Image.open("cosa.png")
imaP = imaP.resize((50, 50))  # Ajustar el tamaño de la imagen
imaP = imaP.convert("RGB")  # Convertir a formato RGB (sin transparencia)
imaP_tk = ImageTk.PhotoImage(imaP)

# Crear una etiqueta para mostrar la imagen del personaje
etiqueta_personaje = tk.Label(marco_1, image=imaP_tk)
etiqueta_personaje.place(x=anCuarto//2-70, y=alPanta//2 - 55)  # Colocar la etiqueta en la esquina superior izquierda de marco_1

# Función para controlar el movimiento del personaje
def mover_personaje(event):
    x, y = etiqueta_personaje.place_info().get('x'), etiqueta_personaje.place_info().get('y')
    if event.keysym == "w":
        etiqueta_personaje.place(x=x, y=int(y) - 10)  # Mover hacia arriba
    elif event.keysym == "a":
        etiqueta_personaje.place(x=int(x) - 10, y=y)  # Mover hacia la izquierda
    elif event.keysym == "s":
        etiqueta_personaje.place(x=x, y=int(y) + 10)  # Mover hacia abajo
    elif event.keysym == "d":
        etiqueta_personaje.place(x=int(x) + 10, y=y)  # Mover hacia la derecha

# Vincular las teclas correspondientes al movimiento del personaje
ventana.bind("<KeyPress-w>", mover_personaje)
ventana.bind("<KeyPress-a>", mover_personaje)
ventana.bind("<KeyPress-s>", mover_personaje)
ventana.bind("<KeyPress-d>", mover_personaje)


###########################################################################
#                               Grafico
#############################################################################

# Calcular el tamaño de la figura en relación con el marco
figura = Figure(figsize=(anPanta // 2 / 100, alPanta // 2 / 100), dpi=100)
grafico = figura.add_subplot(111)

# Crear el lienzo para mostrar el gráfico en el marco_2
canvas = FigureCanvasTkAgg(figura, master=marco_2)
canvas.draw()
canvas.get_tk_widget().pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

# Lista para almacenar los datos del gráfico y la tabla
datos_grafico = []


# Función para actualizar el gráfico y la tabla
def actualizar_grafico_tabla():
    # Limpiar el gráfico anterior
    grafico.clear()
    
    # Crear el nuevo gráfico con los datos almacenados
    distancias, trabajos = zip(*datos_grafico)
    grafico.plot(distancias, trabajos)
    grafico.set_xlabel("Distancia (m)")
    grafico.set_ylabel("Trabajo (J)")
    grafico.set_title("Gráfico de Trabajo Mecánico")
    grafico.grid(True)
    
    # Actualizar el gráfico en la interfaz
    canvas.draw()
    
    # Actualizar la tabla con los datos almacenados
    actualizar_tabla()

####################################################################
#                               Tabla
###################################################################

# Crear el Treeview (tabla)
tabla = ttk.Treeview(marco_4)
tabla.pack(side=tk.TOP, fill=tk.BOTH, expand=True)

# Definir las columnas de la tabla
tabla['columns'] = ("Distancia", "Trabajo")

# Formato de las columnas
tabla.column("#0", width= anCuarto//3, stretch=tk.NO)
tabla.column("Distancia", width=anCuarto//3, anchor=tk.CENTER)
tabla.column("Trabajo", width=anCuarto//3, anchor=tk.CENTER)

# Encabezados de las columnas
tabla.heading("#0", text="", anchor=tk.CENTER)
tabla.heading("Distancia", text="Distancia (m)", anchor=tk.CENTER)
tabla.heading("Trabajo", text="Trabajo (J)", anchor=tk.CENTER)


# Función para actualizar la tabla con los datos almacenados
def actualizar_tabla():
    # Limpiar los datos anteriores de la tabla
    tabla.delete(*tabla.get_children())
    
    # Agregar los datos a la tabla
    for i, (distancia, trabajo) in enumerate(datos_grafico, start=1):   
        tabla.insert("", "end", text=str(i), values=(distancia, trabajo))

########################################################################
#                               Calculo
######################################################################

# Crear los widgets para ingresar los datos
label_fuerza = tk.Label(marco_3, text="Fuerza (N):")
label_fuerza.pack()

entry_fuerza = tk.Entry(marco_3, width=anCuarto//9, justify="center")
entry_fuerza.pack()

label_distancia = tk.Label(marco_3, text="Distancia (m):")
label_distancia.pack()

entry_distancia = tk.Entry(marco_3, width=anCuarto//9, justify="center")
entry_distancia.pack()


# Función para calcular el trabajo
def calcular_trabajo():
    try:
        fuerza = float(entry_fuerza.get())
        distancia = float(entry_distancia.get())
        
        trabajo = fuerza * distancia
        
        label_resultado.config(text=f"El trabajo es: {trabajo} J")
        
        # Agregar los datos a la lista
        datos_grafico.append((distancia, trabajo))
        
        # Actualizar el gráfico y la tabla
        actualizar_grafico_tabla()
        
    except ValueError:
        label_resultado.config(text="Ingrese valores numéricos válidos")

# Botón para calcular el trabajo
btn_calcular = tk.Button(marco_3, text="Calcular", command=calcular_trabajo)
btn_calcular.pack()

# Etiqueta para mostrar el resultado
label_resultado = tk.Label(marco_3, text="")
label_resultado.pack()



# Vincular las teclas correspondientes al movimiento del personaje
ventana.bind("<Key>", mover_personaje)
# Darle el enfoque a la ventana para recibir eventos de teclado
ventana.focus_set()
# Iniciar el bucle de eventos
ventana.mainloop()
